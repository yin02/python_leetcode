### 1. **Kth Largest Element in a Stream**

**Difficulty**: Easy

#### Description:
Design a class that finds the kth largest element in a stream. Initially, the stream is empty, and you can add numbers.

#### Example:
```python
Input:
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
Output: [null, 4, 5, 5, 8, 8]
```

### Solution

```py

class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        # minHeap w/ K largest integers
        self.minHeap, self.k = nums, k
        heapq.heapify(self.minHeap)
        while len(self.minHeap) > k:
            heapq.heappop(self.minHeap)

    def add(self, val: int) -> int:
        heapq.heappush(self.minHeap, val)
        if len(self.minHeap) > self.k:
            heapq.heappop(self.minHeap)
        return self.minHeap[0]
```

---

### 2. **Last Stone Weight**

**Difficulty**: Easy

#### Description:
You are given an array of stones where each stone has a weight. You smash the two heaviest stones together. Return the weight of the last remaining stone, or 0 if all are destroyed.

#### Example:
```python
Input: stones = [2,7,4,1,8,1]
Output: 1
```
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        stones = [-s for s in stones]
        heapq.heapify(stones)
        while len(stones) >1:
            first = heapq.heappop(stones)
            second = heapq.heappop(stones)
            if second > first:
                heapq.heappush(stones,first-second)
        stones.append(0)
        return abs(stones[0])
---

### 3. **K Closest Points to Origin**

**Difficulty**: Medium

#### Description:
Given an array of points and an integer `k`, return the `k` closest points to the origin.

#### Example:
```python
Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
```
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        minHeap = []
        for x,y in points:
            dist = (x**2)+(y**2)
            minHeap.append((dist,x,y))
        
        heapq.heapify(minHeap)
        res = []
        for _ in range(k):
            dist,x,y = heapq.heappop(minHeap)
            res.append((x,y))
        return res
---

### 4. **Kth Largest Element in an Array**
快速排序（QuickSort）的时间复杂度主要取决于如何选择支点（pivot）以及数组的初始状态。以下是对快速排序时间复杂度 \(O(n)\) 和 \(O(n \log n)\) 的详细解释：

### 快速排序时间复杂度分析

1. **快速排序的工作原理**：
   - 快速排序采用分而治之的策略。首先选择一个支点（pivot），然后将数组分为两部分：左边部分的所有元素都小于支点，右边部分的所有元素都大于支点。接着，对这两部分进行递归排序。

2. **时间复杂度情况**：
   - **最佳情况 \(O(n \log n)\)**：
     - 在最佳情况下，每次选择的支点都能将数组均匀地分为两部分。假设数组有 \(n\) 个元素，快速排序在每层递归中大约处理 \(n\) 个元素，而递归的层数是对数级别的（\(\log n\)）。
     - 因此，最佳情况的时间复杂度为：
       \[
       T(n) = n + T\left(\frac{n}{2}\right) + T\left(\frac{n}{2}\right) \implies O(n \log n)
       \]

   - **平均情况 \(O(n \log n)\)**：
     - 大多数情况下，选择的支点不会总是最小或最大，而是随机分布。这导致的分区通常较为平衡，仍然是 \(O(n \log n)\)。

   - **最坏情况 \(O(n^2)\)**：
     - 当输入数组是已排序的（或逆序的），且每次选择的支点都是极端值（例如，第一个元素或最后一个元素），则分区不平衡。这种情况下，每次递归调用的有效元素数量减少得很少，递归的深度将达到 \(n\)，因此总时间复杂度为：
       \[
       T(n) = n + T(n-1) \implies O(n^2)
       \]

### 为什么会出现 \(O(n)\) 的情况

在实际使用中，有时候我们可能会看到某个具体实现的快速排序在某些情况下表现为线性时间 \(O(n)\)。这通常不是整个排序过程的时间复杂度，而是指在某些步骤中处理数据的时间。例如：

- **划分过程**：在某些特定情况下，比如我们只是进行一次分区操作，不进行递归时，处理 \(n\) 个元素的划分确实是 \(O(n)\)。
- **快速选择算法（QuickSelect）**：在查找第 k 大元素的情况下，QuickSelect 的平均时间复杂度为 \(O(n)\)，这是因为它在平均情况下只关注一个分区，而不是排序整个数组。

### 总结

快速排序的时间复杂度通常为 \(O(n \log n)\)，但在特定情况下（如不平衡分区）可能变为 \(O(n^2)\)。划分过程本身可以在 \(O(n)\) 的时间内完成，但完整排序的时间复杂度在最坏情况下会退化为 \(O(n^2)\)。为了优化性能，通常会采用随机化支点选择或三路划分等策略来确保平均性能更接近 \(O(n \log n)\)。
**Difficulty**: Medium

在寻找第 k 大元素的过程中，使用快速选择算法（QuickSelect）时，只关注一个分区的原因在于以下几点：

### 1. 问题定义

- 在找第 k 大元素时，实际上你并不需要对整个数组进行排序，只需要确定出第 k 大的元素是什么。换句话说，目标是找到一个元素，它的位置应该在排序后的数组中的索引为 \( n-k \) 的位置（假设数组为从小到大的顺序）。

### 2. 快速选择算法的工作原理

- 快速选择算法通过选择一个支点（pivot）来分割数组。假设你选择的支点将数组分为三个部分：
  - **左边部分**：所有元素都大于支点。
  - **中间部分**：与支点相等的元素（如果有）。
  - **右边部分**：所有元素都小于支点。

### 3. 只关注一个分区的理由

当你选择支点后，基于支点的值，你可以确定下列几种情况：

1. **如果 k 小于或等于左边部分的大小**：
   - 这意味着第 k 大的元素位于左边部分。因此你可以只递归地在左边部分查找第 k 大的元素。你会忽略右边部分，因为它不可能包含第 k 大的元素。

2. **如果 k 大于左边部分的大小加上中间部分的大小**：
   - 这表示第 k 大的元素在右边部分。你可以递归地在右边部分查找第 \( k - \text{left\_size} - \text{mid\_size} \) 大的元素。此时你也可以忽略左边部分，因为它们的值都大于当前的支点，不可能是第 k 大的元素。

3. **如果 k 在左边部分的大小和左边部分加上中间部分的大小之间**：
   - 这意味着第 k 大的元素就是支点（pivot）本身。此时可以直接返回支点的值。

### 4. 效率

由于每次递归只处理一个分区，QuickSelect 的平均时间复杂度为 \(O(n)\)，因为你每次都能大幅减少需要处理的元素数量。这使得 QuickSelect 相较于其他排序方法（如快速排序）更为高效，尤其在仅需寻找第 k 大元素的场景中。

### 总结

寻找第 k 大元素的过程只关注一个分区的原因在于问题的性质以及快速选择算法的工作原理。通过选择支点并对数组进行分割，你能够有效地缩小查找范围，从而避免不必要的计算。这样做使得算法的效率显著提高，平均时间复杂度降至 \(O(n)\)。



#### Description:
Find the kth largest element in an unsorted array.

#### Example:
```python
Input: [3,2,1,5,6,4], k = 2
Output: 5
```
```py

# Solution: Sorting
# Time Complexity:
#   - Best Case: O(n)
#   - Average Case: O(n*log(n))
#   - Worst Case:O(n*log(n))
# Extra Space Complexity: O(n)
class Solution1:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums.sort()
        return nums[len(nums) - k]


import random
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        pivot = random.choice(nums)
        left = [num for num in nums if num > pivot]
        mid = [num for num in nums if num == pivot]
        right = [num for num in nums if num < pivot]

        length_left = len(left)
        length_right = len(right)
        length_mid = len(mid)
        if k <= length_left:
            return self.findKthLargest(left, k)
        elif k > length_left + length_mid:
            return self.findKthLargest(right, k - length_mid - length_left)
        else:
            return mid[0]


class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # 将 k 转换为对应于最小元素的索引
        # k 是第 k 大元素，我们需要找出数组中的第 len(nums) - k 个最小元素
        k = len(nums) - k
        
        def quickSort(l: int, r: int) -> int:
            # 选择最后一个元素作为支点
            p = nums[r]
            # 初始化指针 l，表示小于支点的元素的边界
            for i in range(l, r):
                if nums[i] < p:
                    nums[l], nums[i] = nums[i], nums[l]  # 交换元素
                    l += 1  # 移动边界总是在后面一个
            # 将支点放到正确的位置
            nums[l], nums[r] = nums[r], nums[l]
            #pivot point update to l 
            p = l
            # p 是支点的最终位置
            # 递归查找
            if p > k:  # 如果支点的位置在目标索引的左侧，说明第 k 大元素在左边
                return quickSort(0, p - 1)
            elif p < k:  # 如果支点的位置在目标索引的右侧，说明第 k 大元素在右边
                return quickSort(p + 1, r)
            else:  # 找到目标元素
                return nums[l]
        
        return quickSort(0, len(nums) - 1)

```

### 5. **Task Scheduler**

**Difficulty**: Medium

#### Description:
Given a list of tasks, return the least amount of time needed to complete them with cooldowns between the same type of tasks.

#### Example:
```python
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
```

---

### 6. **Design Twitter**

**Difficulty**: Medium

#### Description:
Design a Twitter-like system that allows users to post tweets, follow others, and retrieve the 10 most recent tweets from their feed.

#### Example:
```python
Input:
["Twitter", "postTweet", "getNewsFeed", "follow", "postTweet", "getNewsFeed"]
[[], [1, 5], [1], [1, 2], [2, 6], [1]]
Output: [null, null, [5], null, null, [6, 5]]
```

---

### 7. **Least Number of Unique Integers after K Removals**

**Difficulty**: Medium

#### Description:
Remove exactly `k` elements from an array to minimize the number of unique integers left.

#### Example:
```python
Input: arr = [4,3,1,1,3,3,2], k = 3
Output: 2
```

---

### 8. **Furthest Building You Can Reach**

**Difficulty**: Medium

#### Description:
Given an array of building heights, bricks, and ladders, determine the furthest building you can reach using ladders and bricks.

#### Example:
```python
Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1
Output: 4
```

---

### 9. **Minimize Deviation in Array**

**Difficulty**: Hard

#### Description:
Minimize the maximum deviation between the largest and smallest numbers in an array by multiplying or dividing elements by 2.

#### Example:
```python
Input: nums = [1,2,3,4]
Output: 1
```

---

### 10. **Maximum Subsequence Score**

**Difficulty**: Medium

#### Description:
Find the maximum score of a subsequence of length `k` with the largest sum of products.

#### Example:
```python
Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3
Output: 12
```

---

### 11. **Single-Threaded CPU**

**Difficulty**: Medium

#### Description:
Simulate task scheduling on a single-threaded CPU. Return the order in which tasks are executed.

#### Example:
```python
Input: tasks = [[1,2],[2,4],[3,2],[4,1]]
Output: [0,2,3,1]
```

---

### 12. **Seat Reservation Manager**

**Difficulty**: Medium

#### Description:
Design a seat reservation system that reserves the lowest numbered available seat.

#### Example:
```python
Input:
["SeatManager", "reserve", "reserve", "unreserve", "reserve"]
[[5], [], [], [2], []]
Output: [null, 1, 2, null, 2]
```

---

### 13. **Process Tasks Using Servers**

**Difficulty**: Medium

#### Description:
Assign tasks to servers to minimize the time required to complete all tasks.

#### Example:
```python
Input: servers = [3,3,2], tasks = [1,2,3,2,1,2]
Output: [2,2,0,2,1,2]
```

---

### 14. **Find the Kth Largest Integer in the Array**

**Difficulty**: Medium

#### Description:
Find the kth largest integer in an array where each element is a string.

#### Example:
```python
Input: nums = ["3","6","7","10"], k = 4
Output: "3"
```

---

### 15. **Reorganize String**

**Difficulty**: Medium

#### Description:
Rearrange a string so that no two adjacent characters are the same. Return the rearranged string, or "" if it's not possible.

#### Example:
```python
Input: s = "aab"
Output: "aba"
```

---

### 16. **Longest Happy String**

**Difficulty**: Medium

#### Description:
Construct the longest possible string without consecutive characters "a", "b", or "c".

#### Example:
```python
Input: a = 1, b = 1, c = 7
Output: "ccacc"
```

---

### 17. **Car Pooling**

**Difficulty**: Medium

#### Description:
Determine if it is possible to pick up and drop off passengers using only one vehicle with a fixed capacity.

#### Example:
```python
Input: trips = [[2,1,5],[3,3,7]], capacity = 4
Output: false
```

---

### 18. **Find Median From Data Stream**

**Difficulty**: Hard

#### Description:
Design a data structure to find the median of a stream of integers.

#### Example:
```python
Input:
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
Output: [null, null, null, 1.5, null, 2]
```

---

### 19. **Maximum Performance of a Team**

**Difficulty**: Hard

#### Description:
Form a team of `k` engineers to maximize the performance score.

#### Example:
```python
Input: speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
Output: 60
```

---

### 20. **IPO**

**Difficulty**: Hard

#### Description:
Find the maximum capital after completing `k` projects from an array of profits and capital requirements.

#### Example:
```python
Input: k = 2, W = 0, profits = [1,2,3], capital = [0,1,1]
Output: 4
```

---

### 21. **Minimum Cost to Hire K Workers**

**Difficulty**: Hard

#### Description:
Calculate the minimum cost to hire `k` workers from an array of quality and wage expectations.

#### Example:
```python
Input: quality = [10,20,5], wage = [70,50,30], k = 2
Output: 105.00000
```

---

### 22. **Number of Flowers in Full Bloom**

**Difficulty**: Hard

#### Description:
Given blooming times, find how many flowers are in full bloom at different time points.

#### Example:
```python
Input: flowers = [[1,10],[3,3]], people = [3,3,3]
Output: [2,2,2]
```

---

### 23. **Constrained Subsequence Sum**

**Difficulty**: Hard

#### Description:
Find the maximum sum of a subsequence with the constraint that the distance between any two elements in the subsequence is at most `k`.

#### Example:
```python
Input: nums = [10,2,-10,5,20], k = 2
Output: 37
```