### 1. **Kth Largest Element in a Stream**

**Difficulty**: Easy

#### Description:
Design a class that finds the kth largest element in a stream. Initially, the stream is empty, and you can add numbers.

#### Example:
```python
Input:
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
Output: [null, 4, 5, 5, 8, 8]
```

### Solution

```py

class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        # minHeap w/ K largest integers
        self.minHeap, self.k = nums, k
        heapq.heapify(self.minHeap)
        while len(self.minHeap) > k:
            heapq.heappop(self.minHeap)

    def add(self, val: int) -> int:
        heapq.heappush(self.minHeap, val)
        if len(self.minHeap) > self.k:
            heapq.heappop(self.minHeap)
        return self.minHeap[0]
```

---

### 2. **Last Stone Weight**

**Difficulty**: Easy

#### Description:
You are given an array of stones where each stone has a weight. You smash the two heaviest stones together. Return the weight of the last remaining stone, or 0 if all are destroyed.

#### Example:
```python
Input: stones = [2,7,4,1,8,1]
Output: 1
```
```py
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        stones = [-s for s in stones]
        heapq.heapify(stones)
        while len(stones) >1:
            first = heapq.heappop(stones)
            second = heapq.heappop(stones)
            if second > first:
                heapq.heappush(stones,first-second)
        stones.append(0)
        return abs(stones[0])
```
---

### 3. **K Closest Points to Origin**

**Difficulty**: Medium

#### Description:
Given an array of points and an integer `k`, return the `k` closest points to the origin.

#### Example:
```python
Input: points = [[1,3],[-2,2]], k = 1
Output: [[-2,2]]
```
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        minHeap = []
        for x,y in points:
            dist = (x**2)+(y**2)
            minHeap.append((dist,x,y))
        
        heapq.heapify(minHeap)
        res = []
        for _ in range(k):
            dist,x,y = heapq.heappop(minHeap)
            res.append((x,y))
        return res
---

### 4. **Kth Largest Element in an Array**

**Difficulty**: Medium

#### Description:
Find the kth largest element in an unsorted array.

#### Example:
```python
Input: [3,2,1,5,6,4], k = 2
Output: 5
```

---

### 5. **Task Scheduler**

**Difficulty**: Medium

#### Description:
Given a list of tasks, return the least amount of time needed to complete them with cooldowns between the same type of tasks.

#### Example:
```python
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
```

```py
from collections impot heapq
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        count = Counter(tasks)
        maxHeap = [-cnt for cnt in count.values()]#次数最多的任务个数
        heapq.heapify(maxHeap)
        time = 0
        q = deque()# [-cnt,idletime]
        while maxHeap or q:
            time +=1
            if not maxHeap:
                time = q[0][1]#second
            else:
                cnt = 1+ heapq.heappop(maxHeap)#执行一次因为是负数加1
                if cnt:# still number
                #剩余次数和冷却时间，在时间线上+n
                    q.append([cnt,time+n])
            # if q is exist, and first job time is current
            if q and q[0][1] == time:
                #append the to the heap
                heapq.heappush(maxHeap,q.popleft()[0])# the count
        return time


```
#### 如果用桶排序的话来想象，那么最后一个桶因为后面时间无所谓，但是要到达最后一个桶，必须要和最大的一样才配进入？n是固定的，所以可以分成桶


是的，你的理解非常接近正确答案。我们可以通过“桶排序”的思维来直观理解这个问题，尤其是关于如何计算最小的调度时间。

### 使用桶排序思维来理解
1. **定义桶的结构**：
   - 可以把每个桶想象成一个时间段，这个时间段长度为 `n + 1`，它包含 **一个出现次数最多的任务** 和它所需要的 **冷却时间**。每个桶表示执行这些任务时所需的时间单位。
   - `n + 1` 的原因是，最大任务需要冷却时间 `n`，并且桶内需要有一个任务本身。

2. **填充桶**：
   - 假设任务列表中有一个任务 `A` 出现最多，次数为 `max_count`，那么我们将这些任务尽量均匀分布到每一个桶中。
   - 比如，任务 `A` 出现 3 次，冷却时间 `n = 2`，那么这些 `A` 任务会被放置到桶中：`A -> (冷却 n 个单位时间) -> A -> (冷却 n 个单位时间) -> A`。
   - 前 `max_count - 1` 个桶是完整的，每个桶需要有一个任务和 `n` 个冷却时间。

3. **最后一个桶的处理**：
   - 最后一个桶因为后面没有再要求冷却时间，所以我们不需要强制冷却，因此这个最后一个桶并不需要强制包含 `n` 个冷却时间。
   - 但是要到达最后一个桶，必须有相同数量的其他任务填充之前的桶。例如，如果有多个任务也同样出现 `max_count` 次数，它们也必须参与到每个桶中，以便顺利填满。

4. **任务分布和闲置时间**：
   - 在填充这些桶时，如果除了任务 `A` 外，还有其他任务出现次数等于 `max_count`，那么这些任务也可以被平行地放入每个桶中，从而减少闲置时间。
   - 例如，如果除了 `A` 外，还有任务 `B` 也出现 3 次，那么我们可以填充这些桶为：`A, B -> (冷却时间 n) -> A, B -> (冷却时间 n) -> A, B`，这样可以避免产生过多的空闲时间。

### 示例说明
假设有任务 `["A", "A", "A", "B", "B", "B", "C", "C"]`，冷却时间 `n = 2`：
1. `A` 和 `B` 的出现次数相等，为 `3`，`C` 出现 `2` 次。
2. `max_count = 3`，即有任务 `A` 和 `B` 出现了最多次数。
3. 使用桶排序的思路来安排这些任务：
   - 前两个桶的安排是：`A, B -> (冷却时间 n)`，也就是说每个桶包含两个主要任务 `A` 和 `B`。
   - 最后一个桶包含：`A, B`，这个最后的桶不需要再等待冷却时间，因为已经完成所有主要任务。

### 公式 `(max_count - 1) * (n + 1)` 与最后一个桶的关系
- `(max_count - 1)`：表示前面完整的桶的数量。
- `(n + 1)`：表示每个桶的长度，包括一个主要任务和 `n` 个冷却时间。
- 最后的一个桶不需要考虑冷却时间，因此实际所需的总时间可能会小于计算出的 `min_time`，这就是为什么需要用 `max(min_time, len(tasks))` 来返回最大值，因为最终的时间不能少于总任务数。

```py
# Greedy algorithm
class Solution(object):
    def leastInterval(self, tasks: List[str], n: int) -> int:
        counter = collections.Counter(tasks)
        max_count = max(counter.values())
        min_time = (max_count - 1) * (n + 1) + \
                    sum(map(lambda count: count == max_count, counter.values()))
    
        return max(min_time, len(tasks))
```



---

### 6. **Design Twitter**

**Difficulty**: Medium

#### Description:
Design a Twitter-like system that allows users to post tweets, follow others, and retrieve the 10 most recent tweets from their feed.

#### Example:
```python
Input:
["Twitter", "postTweet", "getNewsFeed", "follow", "postTweet", "getNewsFeed"]
[[], [1, 5], [1], [1, 2], [2, 6], [1]]
Output: [null, null, [5], null, null, [6, 5]]
```


```py
from collections import defaultdict
import heapq
from typing import List

class Twitter:
    def __init__(self):
        # 用于计数每条推文的顺序，确保推文按时间顺序排列
        self.count = 0
        # 存储每个用户的推文列表，userId -> list of [count, tweetId]
        self.tweetMap = defaultdict(list)
        # 存储每个用户关注的用户集合，userId -> set of followeeId
        self.followMap = defaultdict(set)

    def postTweet(self, userId: int, tweetId: int) -> None:
        # 用户发布一条推文，将推文添加到用户的推文列表中
        # 使用负的 self.count 确保最新的推文在最小堆中具有最高优先级
        self.tweetMap[userId].append([self.count, tweetId])
        self.count -= 1

    def getNewsFeed(self, userId: int) -> List[int]:
        # 初始化返回结果列表，用于存储最新的推文 ID
        res = []
        # 初始化最小堆，用于存储用户及其关注者的推文，最多保留 10 条最新推文
        minHeap = []
        
        # 用户关注自己，这样用户可以看到自己的推文
        # 这是一种常见的社交媒体逻辑，用户自然应该看到自己发布的内容
        self.followMap[userId].add(userId)  # 确保用户自己也在关注列表中
        
        # 遍历用户关注的所有用户（包括自己），获取每个用户的推文
        for followeeId in self.followMap[userId]:
            if followeeId in self.tweetMap:
                # 获取该关注者的最新推文的索引（即推文列表的最后一个元素）
                index = len(self.tweetMap[followeeId]) - 1
                
                # 获取推文的计数和推文 ID
                # 计数用于按照时间顺序排序推文，推文 ID 用于标识具体的推文
                count, tweetId = self.tweetMap[followeeId][index]
                
                # 将该推文的信息加入最小堆中，包含计数、推文 ID、用户 ID 和前一个推文的索引
                # 使用最小堆来确保我们可以按顺序获取最新的推文
                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])
        
        # 获取最多 10 条最新推文
        while minHeap and len(res) < 10:
            # 从堆中弹出计数最小（即时间最晚）的推文
            count, tweetId, followeeId, index = heapq.heappop(minHeap)
            
            # 将该推文的 ID 添加到结果列表中
            res.append(tweetId)
            
            # 如果该用户还有前面的推文，继续获取前一条推文的信息并加入堆中
            # 这样可以继续获取该用户的更早的推文，直到堆为空或者获取到 10 条推文
            if index >= 0:
                count, tweetId = self.tweetMap[followeeId][index]
                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])
        
        # 返回新闻推送的推文 ID 列表，包含用户和关注者的最多 10 条最新推文
        return res

    def follow(self, followerId: int, followeeId: int) -> None:
        # 用户关注另一个用户，将该用户添加到关注列表中
        self.followMap[followerId].add(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        # 用户取消关注另一个用户，如果该用户在关注列表中则将其移除
        # 确保用户不能取消关注自己
        if followeeId in self.followMap[followerId] and followeeId != followerId:
            self.followMap[followerId].remove(followeeId)

```

---

### 7. **Least Number of Unique Integers after K Removals**

**Difficulty**: Medium

#### Description:
Remove exactly `k` elements from an array to minimize the number of unique integers left.

#### Example:
```python
Input: arr = [4,3,1,1,3,3,2], k = 3
Output: 2
```

---

### 8. **Furthest Building You Can Reach**

**Difficulty**: Medium

#### Description:
Given an array of building heights, bricks, and ladders, determine the furthest building you can reach using ladders and bricks.

#### Example:
```python
Input: heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1
Output: 4
```

---

### 9. **Minimize Deviation in Array**

**Difficulty**: Hard

#### Description:
Minimize the maximum deviation between the largest and smallest numbers in an array by multiplying or dividing elements by 2.

#### Example:
```python
Input: nums = [1,2,3,4]
Output: 1
```

---

### 10. **Maximum Subsequence Score**

**Difficulty**: Medium

#### Description:
Find the maximum score of a subsequence of length `k` with the largest sum of products.

#### Example:
```python
Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3
Output: 12
```

---

### 11. **Single-Threaded CPU**

**Difficulty**: Medium

#### Description:
Simulate task scheduling on a single-threaded CPU. Return the order in which tasks are executed.

#### Example:
```python
Input: tasks = [[1,2],[2,4],[3,2],[4,1]]
Output: [0,2,3,1]
```

---

### 12. **Seat Reservation Manager**

**Difficulty**: Medium

#### Description:
Design a seat reservation system that reserves the lowest numbered available seat.

#### Example:
```python
Input:
["SeatManager", "reserve", "reserve", "unreserve", "reserve"]
[[5], [], [], [2], []]
Output: [null, 1, 2, null, 2]
```

---

### 13. **Process Tasks Using Servers**

**Difficulty**: Medium

#### Description:
Assign tasks to servers to minimize the time required to complete all tasks.

#### Example:
```python
Input: servers = [3,3,2], tasks = [1,2,3,2,1,2]
Output: [2,2,0,2,1,2]
```

---

### 14. **Find the Kth Largest Integer in the Array**

**Difficulty**: Medium

#### Description:
Find the kth largest integer in an array where each element is a string.

#### Example:
```python
Input: nums = ["3","6","7","10"], k = 4
Output: "3"
```

---

### 15. **Reorganize String**

**Difficulty**: Medium

#### Description:
Rearrange a string so that no two adjacent characters are the same. Return the rearranged string, or "" if it's not possible.

#### Example:
```python
Input: s = "aab"
Output: "aba"
```

---

### 16. **Longest Happy String**

**Difficulty**: Medium

#### Description:
Construct the longest possible string without consecutive characters "a", "b", or "c".

#### Example:
```python
Input: a = 1, b = 1, c = 7
Output: "ccacc"
```

---

### 17. **Car Pooling**

**Difficulty**: Medium

#### Description:
Determine if it is possible to pick up and drop off passengers using only one vehicle with a fixed capacity.

#### Example:
```python
Input: trips = [[2,1,5],[3,3,7]], capacity = 4
Output: false
```

---

### 18. **Find Median From Data Stream**

**Difficulty**: Hard

#### Description:
Design a data structure to find the median of a stream of integers.

#### Example:
```python
Input:
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
Output: [null, null, null, 1.5, null, 2]
```

---

### 19. **Maximum Performance of a Team**

**Difficulty**: Hard

#### Description:
Form a team of `k` engineers to maximize the performance score.

#### Example:
```python
Input: speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2
Output: 60
```

---

### 20. **IPO**

**Difficulty**: Hard

#### Description:
Find the maximum capital after completing `k` projects from an array of profits and capital requirements.

#### Example:
```python
Input: k = 2, W = 0, profits = [1,2,3], capital = [0,1,1]
Output: 4
```

---

### 21. **Minimum Cost to Hire K Workers**

**Difficulty**: Hard

#### Description:
Calculate the minimum cost to hire `k` workers from an array of quality and wage expectations.

#### Example:
```python
Input: quality = [10,20,5], wage = [70,50,30], k = 2
Output: 105.00000
```

---

### 22. **Number of Flowers in Full Bloom**

**Difficulty**: Hard

#### Description:
Given blooming times, find how many flowers are in full bloom at different time points.

#### Example:
```python
Input: flowers = [[1,10],[3,3]], people = [3,3,3]
Output: [2,2,2]
```

---

### 23. **Constrained Subsequence Sum**

**Difficulty**: Hard

#### Description:
Find the maximum sum of a subsequence with the constraint that the distance between any two elements in the subsequence is at most `k`.

#### Example:
```python
Input: nums = [10,2,-10,5,20], k = 2
Output: 37
```