### 相同的数子move to the last 最后一个, 且在区间内
```py
            while i+1 < len(nums) and nums[i] == nums[i+1]:
                i +=1
        # 右边的大的话（上升）且在范围的情况，因为mid+1 检查右边就行
            if mid < len(nums) - 1 and nums[mid] < nums[mid+1]:
        # 在范围内，左边大的话（下降） 且在范围内的情况，因为i-1
        if mid > 0 and nums[mid] < nums[mid-1]:
```
### 旋转数组的左右边 都是跟  L比 或者nums【0】，右边就是nums【-1】
```
        # 搜索左半部分
        if nums[l] <= nums[mid]
        # 搜索右半部分
        if nums[mid] < nums[l]
```
### least number of unique integer after k removal
### elminate/remove the smallest frequency number
```py
heapify 是 linear time，pop是logn，但是heap比sort 更快
def findLeastNumOfUniqueInts(self,arr,k):
    freq = Counter(arr)
    heap = list(freq.values())
    heapq.heapify(heap)

    res = len(heap)
    while k >0:
        f = heapq.heappop(heap)
        if k >= f:
            k -= f
            res -=1
    return res
```


### freq with bucket sort![alt text](image.png)
不care number是几，只在乎freq是1的两个，2的1个

因为least肯定是freq频率最少的先去除，能整个去掉最好， 
和上面不一样的是有两个数字的 freq都是这个的话，结果是-2的，有几个-几个
freq[1] 在freq——list里面代表 频率1 的有几个
### 如果不能全部移除的话 math， k/f round down看看自己能移除几个
```py
freq = Counter(arr)
freq_list = [0] *(len(arr)+1 )
for n,f in freq.items():
    freq_list[f] +=1
res = len(freq)
for f in range(1,len(freq_list)):
    remove = freq_list[f] # 移除的freq【n】 某个频率的数
    if k >= f *remove:
        k -= remove
        res -= remove
    else:
        remove = k//f
        res -= remove
        break # 下面的没有必要了
return res
```


### 
```py

```


### 
```py

```

### 
```py

```


### 
```py

```


### 
```py

```


### 
```py

```


### 
```py

```


### 
```py

```


### 
```py

```


### 
```py

```


### 
```py

```



### 
```py

```



### 
```py

```


### 
```py

```


### 
```py

```

### 
```py

```

### 
```py

```

### 
```py

```
### 
```py

```
### 
```py

```
### 
```py

```
### 
```py

```
### 
```py

```
### 
```py

```

### 
```py

```
### 
```py

```
### 
```py

```
