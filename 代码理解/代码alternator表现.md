使用 `mod 2` 来优化的思路是基于 **滚动数组** 技术，将二维 `dp` 数组的空间需求从 `O(n * target)` 降低到 `O(2 * target)`。通过 `mod 2`，我们可以在两个数组之间交替使用存储空间，实现空间压缩。

### 为什么可以使用 `mod 2` 进行优化

在动态规划的过程中，每一层的状态只依赖于上一层的状态。也就是说，在计算 `dp[i][c]` 的值时，我们只需要 `dp[i-1][c]` 以及 `dp[i-1][c - weight[i]]`，而不需要再保留 `dp[i-2][*]` 及更早的状态。因此，我们只需要两行来存储当前行和上一行的数据。

### 优化思路

通过 `mod 2` 的操作，我们可以在两个数组之间来回切换：

1. 将 `f[i % 2]` 表示第 `i` 行，`f[(i + 1) % 2]` 表示下一行。
2. 当计算第 `i + 1` 行时，实际上使用的是 `f[i % 2]` 的结果。
3. 使用 `f[(i + 1) % 2][c]` 来更新当前行的状态，这样我们只需要两行数据（两行的数组），而不需要完整的 `n` 行空间。

### 代码中的 `mod 2` 实现

在代码中，`f[i % 2]` 表示第 `i` 行的状态，`f[(i + 1) % 2]` 表示第 `i + 1` 行的状态。这让我们在每次更新时只需要在 `f[0]` 和 `f[1]` 之间交替使用，减少了空间的占用。

```python
f = [[0] * (target + 1) for _ in range(2)]
f[0][0] = 1  # 初始状态，容量为0时的方式数为1

for i, x in enumerate(nums):
    for c in range(target + 1):
        if c < x:
            f[(i + 1) % 2][c] = f[i % 2][c]
        else:
            f[(i + 1) % 2][c] = f[i % 2][c] + f[i % 2][c - x]

return f[n % 2][target]
```

### 示例解释

假设我们有物品和容量的组合，在遍历时：

1. `f[0]` 存储当前行的状态。
2. `f[1]` 存储下一行的状态。
3. 每当一行的状态计算完毕后，通过 `mod 2` 进行交换，使 `f[1]` 成为新的当前行，而 `f[0]` 则用来存储下一行的状态。

### 总结

- `mod 2` 的滚动数组技术将二维 `dp` 压缩成两行。
- 每次只需更新两行中的一个，确保空间复杂度为 `O(2 * target)`。
- 在代码中，`f[i % 2]` 表示当前行，`f[(i + 1) % 2]` 表示下一行，实现交替更新。