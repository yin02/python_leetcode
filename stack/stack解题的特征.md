要想到用 **stack** 来解决问题，通常需要观察到问题具有 **某些特定的特征**。这些特征可以帮助我们识别问题是否适合用栈来处理。

### **栈解决问题的常见特征**

1. **问题涉及顺序性**：
   - 栈是一种 **后进先出（LIFO）** 的数据结构，所以它常用于解决需要按顺序处理数据的问题，尤其是 **回溯** 或需要存储临时状态的问题。例如，遍历元素时需要记住之前的某些元素，并在特定条件下将这些元素丢弃。

2. **需要找到“最近的”或“下一个的”元素**：
   - 当问题要求找到一个元素相对于其他元素的最近更大、最近更小等类似关系时，栈可以非常有效。例如，**下一个更大元素**、**下一个更小元素**等问题。

3. **需要维护一个单调序列**：
   - 栈通常用于构造 **单调栈**，即栈内的元素始终保持单调递增或单调递减。在这种情况下，栈可以用于快速找到特定元素相对于其他元素的顺序关系。

4. **回溯问题**：
   - 当需要在处理某个问题时能够 **回退到之前的某个状态** 时，栈是一个常用的工具。例如，括号匹配问题、求解表达式的问题。

5. **递归的替代**：
   - 栈可以用来模拟递归调用。当问题具有递归性质时（例如深度优先搜索、树的遍历等），可以通过显式使用栈来代替隐式的递归调用。
  
5. **可以记住**：
   - 记住一些东西，直到某些规则开始触发


### **用栈解决的典型 LeetCode 题目及其特征**

1. **括号匹配类问题**：
   - 题目特征：字符串中的括号必须按照正确的顺序闭合或匹配。
   - 例子：`20. Valid Parentheses`、`32. Longest Valid Parentheses`
   - 思路：用栈来跟踪左括号，每当遇到右括号时，检查栈顶元素是否匹配。
   
2. **单调栈问题**：
   - 题目特征：需要找到一个元素相对于其他元素的最近的顺序关系，如最近的更大或更小元素。
   - 例子：
     - `496. Next Greater Element I`
     - `503. Next Greater Element II`
     - `739. Daily Temperatures`
     - `84. Largest Rectangle in Histogram`
   - 思路：使用单调栈（递增或递减）来在遍历数组时跟踪还没有找到“下一个更大/小元素”的元素。
   
3. **求解表达式类问题**：
   - 题目特征：需要根据给定的数学表达式进行计算，可能包含括号、加减乘除等运算符。
   - 例子：`224. Basic Calculator`、`227. Basic Calculator II`
   - 思路：栈可以用于存储操作数、运算符，结合优先级进行计算。栈在处理嵌套括号时尤为有效。

4. **二叉树的遍历**：
   - 题目特征：遍历二叉树，通常要求实现中序遍历、前序遍历或后序遍历，可能要在不使用递归的情况下实现。
   - 例子：`94. Binary Tree Inorder Traversal`、`144. Binary Tree Preorder Traversal`
   - 思路：栈可以用来模拟递归调用，实现二叉树的深度优先遍历。

5. **回文检查类问题**：
   - 题目特征：检查字符串或链表是否是回文。
   - 例子：`234. Palindrome Linked List`
   - 思路：使用栈存储前半部分元素，然后与后半部分元素进行比较。

6. **直方图问题**：
   - 题目特征：处理一系列高度信息，要求找出最大面积的矩形或其他几何形状。
   - 例子：`84. Largest Rectangle in Histogram`
   - 思路：用栈来存储高度信息，通过遍历来计算每个可能的矩形面积。

7. **最近的某个更大的元素或更小的元素**：
   - 题目特征：找出某个元素相对于其他元素的最近的更大或更小的元素。
   - 例子：`901. Online Stock Span`、`739. Daily Temperatures`
   - 思路：使用栈来存储候选元素，在遇到符合条件的元素时弹出栈顶并计算结果。

### 总结

要想到用 **栈** 来解题，首先要识别出问题的这些 **特征**：
- 处理数据的顺序性很重要。
- 需要找到元素的“最近”或“下一个”元素。
- 问题有回溯或递归的性质。
- 需要维护一个单调递增或递减的序列。

这些特征为使用栈提供了线索，从而使得问题能够高效解决。